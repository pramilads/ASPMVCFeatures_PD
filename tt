import { Component, Input, Output, EventEmitter, QueryList, ViewChildren, ElementRef, ViewChild  } from '@angular/core';
import { NgbModal, NgbModalOptions } from '@ng-bootstrap/ng-bootstrap';
import { MatTableDataSource } from '@angular/material/table';
import { FormControl } from '@angular/forms';

import { OrderEditComponent } from './../order-edit/order-edit.component';
import { OrderInfoUpdateModel, OrdersToSchedule } from './../../../shared/models/search.model';
import { SchedulerService } from 'src/app/core/services/scheduler.service';
import { MatSort } from '@angular/material/sort';

@Component({
  selector: 'order-list',
  templateUrl: './order-list.component.html'
})
export class OrderListComponent {
  @ViewChildren('matSelect') matSelect: QueryList<ElementRef>;

  formCtrlOrderKey = new FormControl();
  formCtrlOrderPlant = new FormControl();
  formCtrlOrderCategory = new FormControl();
  formCtrlOrderType = new FormControl();
  formCtrlOrderDesc = new FormControl();
  formCtrlMAT = new FormControl();
  formCtrlComments = new FormControl();

  @Input() inputOrderList: any = [];
  @Output() outputOrderList = new EventEmitter<any>();
  lstOrdersUpdated: any = [];
  ordersSelected: Array<OrdersToSchedule> = [];
  displayedColumns = ['schdOrder','orderKey', 'plant', 'description', 'orderType', 'mat', 'orderCategory', 'scheduledStart', 
                      'scheduledFinish', 'basicFinishDate', 'omOrCapital', 'unloadingPoint', 'missDig', 'missDigDate', 'comments',
                      'custComm', 'coordReq', 'thirdParty', 'bore', 'welder', 'hydro', 'sewer', 'ttc', 'specEquip', 'planned'];
  dataSource = new MatTableDataSource();
  filterValues = {};
  filterSelectObj = [];
  @ViewChild(MatSort) sort: MatSort;

  constructor(private modalService: NgbModal, private schedulerService: SchedulerService){
    // Object to create Filter for
    this.filterSelectObj = [
      {
        name: 'Order Key',
        columnProp: 'orderKey',
        options: [],
        formCtrl: this.formCtrlOrderKey
      },
      {
        name: 'Order Plant',
        columnProp: 'plant',
        options: [],
        formCtrl: this.formCtrlOrderPlant
      },
      {
        name: 'Order Category',
        columnProp: 'orderCategory',
        options: [],
        formCtrl: this.formCtrlOrderCategory
      },
      {
        name: 'Order Type',
        columnProp: 'orderType',
        options: [],
        formCtrl: this.formCtrlOrderType
      },
      {
        name: 'Order Desc',
        columnProp: 'description',
        options: [],
        formCtrl: this.formCtrlOrderDesc
      }
    ]
  }

  ngOnInit(){
    this.dataSource.data = this.inputOrderList;
    this.dataSource.sort = this.sort;
    this.dataSource.sortingDataAccessor = (item, property) => {
      switch (property) {
         case 'basicFinishDate': return new Date(item[property]);
         case 'scheduledStart': return new Date(item[property]);
         case 'scheduledFinish': return new Date(item[property]);         
         case 'missDigDate': return new Date(item[property]);
         default: return item[property];
      }
    };

    this.filterSelectObj.filter((o) => {
      o.options = this.getFilterObject(this.inputOrderList, o.columnProp);
    });

    // Overrride default filter behaviour of Material Datatable
    this.dataSource.filterPredicate = this.createFilter();
  }

  ngAfterViewInit(): void {
    this.dataSource.sort = this.sort;
  }

  // Get Uniqu values from columns to build filter
  getFilterObject(fullObj, key) {
    const uniqChk = [];
    fullObj.filter((obj) => {
      if (!uniqChk.includes(obj[key])) {
        uniqChk.push(obj[key]);
      }
      return obj;
    });
    return uniqChk;
  }

   // Custom filter method fot Angular Material Datatable
   createFilter() {
    let filterFunction = function (data: any, filter: string): boolean {
    let searchTerms = JSON.parse(filter);
    let isFilterSet = false;
    for (const col in searchTerms) {
        if (searchTerms[col].toString() !== '') {
        isFilterSet = true;
        } else {
        delete searchTerms[col];
        }
    }

    let nameSearch = () => {
        let found = false;
        if (isFilterSet) {
        for (const col in searchTerms) {          
            searchTerms[col].forEach(word => {
            if (data[col]?.toString().toLowerCase().indexOf(word.trim().toLowerCase().split(' ')) != -1 && isFilterSet) {             
                found = true;
            }
            });
        }
        return found
        } else {
        return true;
        }
    }
    return nameSearch()
    }
    return filterFunction
}

  //Method to update the checkboxes changes in order list table
  saveOrderDetails(){
    let ordersToUpdate = this.inputOrderList.filter(order => this.lstOrdersUpdated.includes(order.workOrderId));


    let lstOrderUpdateModel = [];

    ordersToUpdate.forEach(orderToUpdate => {
      let orderInfoUpdateModel = new OrderInfoUpdateModel();
      orderInfoUpdateModel.WorkOrderId = orderToUpdate.workOrderId;
      orderInfoUpdateModel.CustComm = orderToUpdate.custComm ? 'Y' : 'N';
      orderInfoUpdateModel.CoordinationReq = orderToUpdate.coordinationReq ? 'Y' : 'N';
      orderInfoUpdateModel.ThirdParty = orderToUpdate.thirdParty ? 'Y' : 'N';
      orderInfoUpdateModel.Bore = orderToUpdate.bore ? 'Y' : 'N';
      orderInfoUpdateModel.Welder = orderToUpdate.welder ? 'Y' : 'N';
      orderInfoUpdateModel.Hydro = orderToUpdate.hydro ? 'Y' : 'N';
      orderInfoUpdateModel.Sewer = orderToUpdate.sewer ? 'Y' : 'N';
      orderInfoUpdateModel.TTC = orderToUpdate.ttc ? 'Y' : 'N';
      orderInfoUpdateModel.SpecialEquipment = orderToUpdate.specialEquipment ? 'Y' : 'N';
      orderInfoUpdateModel.Planned = orderToUpdate.planned ? 'Y' : 'N';

      lstOrderUpdateModel.push(orderInfoUpdateModel);
    });
    
    this.schedulerService.saveOrderDetails(lstOrderUpdateModel).subscribe(res => {
      alert('changes saved successfully');
    });
  }

  editOrder(workOrderId){
    const modalOptions: NgbModalOptions = {
      size: 'lg',
      keyboard: false,
      backdrop: 'static',

    };
    const modalRef = this.modalService.open(OrderEditComponent, modalOptions); 
    const orderInfo =  JSON.parse(JSON.stringify(this.inputOrderList));//get a copy of employee list
    modalRef.componentInstance.inputOrderInfo = orderInfo.filter(order => order.workOrderId === workOrderId)[0];

    modalRef.result.then((resolveReason) => {
      if (resolveReason == 'save'){
        this.outputOrderList.emit();
      }
      else if (resolveReason == 'cancel'){
        alert('do nothing');
      }
    });
  }

  checkboxUpdated(workOrderId){
    this.lstOrdersUpdated.push(workOrderId);
  } 

  selectOrdersForScheduling(workOrderId, event){
    let schdOrder = new OrdersToSchedule();
    schdOrder.WorkOrderId = workOrderId;
    schdOrder.IsSelected = (event.target.checked) ? 'Y' : 'N';

    const orderFromDB = this.inputOrderList.filter((order) => order.workOrderId == workOrderId)[0];

    const index = this.ordersSelected.findIndex((e) => e.WorkOrderId == workOrderId);
    
    if (index == -1 && orderFromDB['isSelected'] != schdOrder.IsSelected)//if order updated
    {
        this.ordersSelected.push(schdOrder);
    } 
    else//if order updated and reverted
    {
        this.ordersSelected = this.ordersSelected.filter(order => order.WorkOrderId != workOrderId);
    }
  }

  saveOrdersForScheduling(){
    this.schedulerService.saveOrdersForScheduling(this.ordersSelected).subscribe();
  }

  getBasicFinishDateStyle(basicFinishDate){
    return new Date(basicFinishDate) <= new Date() ? 'orderPastDate' : 'orderFutureDate'
  }

  ok(index, filter){
       this.filterChange(filter.columnProp, filter.formCtrl.value);
    this.matSelect['_results'][index].close();
  }

  cancel(index, filter){
    filter.formCtrl.setValue('');
    this.filterChange(filter.columnProp, filter.formCtrl.value);
    this.matSelect['_results'][index].close();
  }

  // Called on Filter change and ok/cancel is clicked
  filterChange(col, val) {
    this.filterValues[col] = val;
    this.dataSource.filter = JSON.stringify(this.filterValues);
  }

  // Reset table filters
  resetFilters() {
    this.filterSelectObj[0].preSelected = [];
    this.filterSelectObj[1].preSelected = [];
    this.filterSelectObj[2].preSelected = [];
    this.filterSelectObj[3].preSelected = [];
    this.filterSelectObj[4].preSelected = [];
    this.filterChange('orderKey', null);
    this.filterChange('plant', null);
    this.filterChange('orderCategory', null);
    this.filterChange('orderType', null);
    this.filterChange('description', null);
    
    this.dataSource.filter = "";

  }
}
